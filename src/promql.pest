// Common
left_paren     = { "(" }
right_paren    = { ")" }
left_brace     = { "{" }
right_brace    = { "}" }
left_bracket   = { "[" }
right_bracket  = { "]" }
comma          = { "," }
eql            = { "=" }
colon          = { ":" }
semicolon      = { ";" }
blank          = { "_" }
times          = { "x" }

eol            = _{ "\n" | "\r" }
tab            = _{ "\t" }
space          = _{ " " | tab | eol }
alpha = _{ ASCII_ALPHA | "_" }
alpha_numeric = _{ alpha | ASCII_DIGIT }
line_comment = @{ "#" ~ ANY* ~ eol }

sub            = { "-" }
add            = { "+" }
mul            = { "*" }
modulo         = { "%" }
div            = { "/" }
eqlc           = { "==" }
neq            = { "!=" }
lte            = { "<=" }
lss            = { "<" }
gte            = { ">=" }
gtr            = { ">" }
eql_regex      = { "=~" }
neq_regex      = { "!~" }
pow            = { "^" }

// Label
label = { alpha ~ alpha_numeric* }
identifier = { alpha_numeric }

// Operators.
and            = { "and" }
or             = { "or" }
unless         = { "unless" }

// Aggregators.
sum            = { "sum" }
avg            = { "avg" }
count          = { "count" }
min            = { "min" }
max            = { "max" }
group          = { "group" }
stddev         = { "stddev" }
stdvar         = { "stdvar" }
topk           = { "topk" }
bottomk        = { "bottomk" }
count_values   = { "count_values" }
quantile       = { "quantile" }

// Keywords.
offset         = { "offset" }
by             = { "by" }
without        = { "without" }
on             = { "on" }
ignoring       = { "ignoring" }
group_left     = { "group_left" }
group_right    = { "group_right" }
boolen         = { "bool" }

// Preprocessors.
start          = { "start" }
end            = { "end" }

// Keywords
aggregate_op = { avg | bottomk | count | count_values | group | max | min | quantile | stddev | stdvar | sum | topk }
unary_op = { add | sub }
match_op = { eql | neq | eql_regex | neq_regex }

// Literals
number = @{
	("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
	~ ("." ~ ASCII_DIGIT+)?
	~ (^"e" ~ (add | sub)? ~ ASCII_DIGIT+)?
}

signed_number = { (add | sub) ~ number }
signed_or_unsigned_number = { (add | sub)? ~ number }

inf = { "inf" }
nan = { "nan" }

uint = { ASCII_DIGIT+ }

string_literal = ${"\"" ~ (char_raw | char_escaped)* ~ "\""}
char_raw = { !("\\" | "\"") ~ ANY }

char_escaped = _{"\\" ~ (^"x" ~ char_byte_inner | "u{" ~ char_unicode_inner ~ "}" | char_predefined_inner) }
char_byte_inner = { ASCII_HEX_DIGIT{2} }
char_unicode_inner = { ASCII_HEX_DIGIT{1, 6} }
char_predefined_inner = { "n" | "r" | "t" | "\\" | "0" | "\"" | "'" }


duration_unit = { "ns" | "us" | "ms" | "s" | "m" | "h" | "d" | "w" | "y" }
duration_part = ${ uint ~ duration_unit }
duration = ${ duration_part+ | uint }

todo = { "TODO" }
// Aggregations
aggregate_expr = { todo }

aggregate_modifier = { todo }

// Binary Expression
binary_expr = { todo }

bin_modifier = { todo }

bool_modifier = { todo }

on_or_ignoring = { todo }

group_modifiers = { todo }

grouping_labels = { todo }

grouping_label_list = { todo }

grouping_label = { todo }

// Function Calls
function_call = { todo }

function_call_body = { todo }

function_call_args = { todo }


// Expressions Inside Parentheses
paren_expr = { todo }

// Offset Modifiers
offset_expr = { todo }

// @Modifiers
step_invariant_expr = { todo }

at_modifier_preprocessors = { start | end }

// Subquery and Range Selector
matrix_selector = { todo }

subquery_expr = { todo }

// Unary Expressions
unary_expr = { todo }

// Vector Selectors
vector_selector = { todo }

label_matchers = { todo }

label_match_list = { todo }

label_matcher = { todo }

// Metric Descriptions
metric = { todo }

metric_identifier = { todo }

label_set = { todo }

label_set_list = { todo }

label_set_item = { todo }

// Series Descriptions
series_description = { todo }

series_values = { todo }

series_item = { todo }

series_value = { todo }

// Metric

// Series Description

// Expression

// Metric Selector

// Main
input = {SOI ~ EOI}
